from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytes
from gmpy2 import invert


def exp():
    from gmpy2 import gcd, next_prime
    e = 0x10001
    x = 113350138578125471637271827037682321496361317426731366252238155037440385105997423113671392038498349668206564266165641194668802966439465128197299073392773586475372002967691512324151673246253769186679521811837698540632534357656221715752733588763108463093085549826122278822507051740839450621887847679420115044512
    d = 27451162557471435115589774083548548295656504741540442329428952622804866596982747294930359990602468139076296433114830591568558281638895221175730257057177963017177029796952153436494826699802526267315286199047856818119832831065330607262567182123834935483241720327760312585050990828017966534872294866865933062292893033455722786996125448961180665396831710915882697366767203858387536850040283296013681157070419459208544201363726008380145444214578735817521392863391376821427153094146080055636026442795625833039248405951946367504865008639190248509000950429593990524808051779361516918410348680313371657111798761410501793645137
    c = 619543409290228183446186073184791934402487500047968659800765382797769750763696880547221266055431306972840980865602729031475343233357485820872268765911041297456664938715949124290204230537793877747551374176167292845717246943780371146830637073310108630812389581197831196039107931968703635129091224513813241403591357678410312272233389708366642638825455844282490676862737715585788829936919637988039113463707959069907015464745700766013573282604376277598510224455044288896809217461295080140187509519005245601483583507547733673523120385089098002298314719617693895392148294399937798485146568296114338393548124451378170302291

    ed = e*d
    for i in range(1, e-1):
        if (ed-1) % i == 0:
            phi = (ed-1)//i
            kp = x*phi - x + 1
            tp = []
            g = 3
            for j in range(999):
                t = pow(g, phi, kp) - 1
                if t > 0 and (t not in tp):
                    tp.append(t)
                g = next_prime(g)
                if len(tp) >= 2:
                    break
            if len(tp) >= 2:
                p = gcd(tp[0], tp[1])
                print(i, 'p = ', p)
                if gcd(x, p) != 1 or p < x:
                    continue
                else:
                    break
    q = invert(x, p)
    n = p*q
    m = pow(c, d, n)
    print(long_to_bytes(m))


if __name__ == '__main__':
    exp()
# 分析过程大佬博客已经很详细,这里不再赘述,仅做简要分析
# 简单来说,就是已知$q{-1} mod\ p, 和d恢复p,q的攻击$,使用类似于已知n,e,d分解n的思路
# $设x=q{-1}\ mod\ p$
# $由\phi=(p-1)\cdot(q-1)=N - (p+q)+1$ , 模上p
# $\phi\ mod\ p = -q+1\ mod\ p$ , 乘以x,有
# $x\cdot\phi \equiv -xq + x \equiv -1+x\ mod\ p$
# 从而$x\phi-x+1\equiv0\ mod\ p,即 x\phi-x+1为p的倍数$
# 不妨令$k_p=x\cdot\phi-x+1$
# $对任意的g,(g,p)=1, 有g\phi \equiv1\ mod\ p\rightarrow (g\phi\ mod\ k_p) \equiv1\ mod\ p$
# $即(g\phi mod\ k_p)-1为p的倍数$,那么只需求得多个值,取GCD即可
# exp
